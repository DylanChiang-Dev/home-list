<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å‰ç«¯é”™è¯¯è¯Šæ–­å·¥å…·</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        h1 {
            color: #2d3748;
            text-align: center;
            margin-bottom: 30px;
        }
        .test-section {
            margin: 20px 0;
            padding: 20px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: #f7fafc;
        }
        .test-section h3 {
            color: #4a5568;
            margin-top: 0;
        }
        .status {
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: bold;
            display: inline-block;
            margin: 5px 0;
        }
        .status.success { background: #c6f6d5; color: #22543d; }
        .status.error { background: #fed7d7; color: #742a2a; }
        .status.warning { background: #fefcbf; color: #744210; }
        .status.info { background: #bee3f8; color: #2a4365; }
        .log {
            background: #1a202c;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            margin: 10px 0;
        }
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        button {
            background: #e53e3e;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 0 10px;
            transition: background 0.2s;
        }
        button:hover {
            background: #c53030;
        }
        button:disabled {
            background: #a0aec0;
            cursor: not-allowed;
        }
        .error-count {
            background: #fed7d7;
            color: #742a2a;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-weight: bold;
        }
        .solution {
            background: #c6f6d5;
            color: #22543d;
            padding: 15px;
            border-radius: 6px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”§ å‰ç«¯é”™è¯¯è¯Šæ–­å·¥å…·</h1>
        
        <div class="controls">
            <button onclick="runErrorDiagnosis()" id="startBtn">å¼€å§‹é”™è¯¯è¯Šæ–­</button>
            <button onclick="simulateErrors()" id="simulateBtn">æ¨¡æ‹Ÿé”™è¯¯åœºæ™¯</button>
            <button onclick="clearLogs()" id="clearBtn">æ¸…é™¤æ—¥å¿—</button>
        </div>
        
        <div id="errorSummary" style="display: none;"></div>
        
        <div class="test-section">
            <h3>ğŸš« ERR_ABORTED é”™è¯¯æ£€æµ‹</h3>
            <div id="abortStatus">ç­‰å¾…æµ‹è¯•...</div>
            <div class="log" id="abortLog"></div>
        </div>
        
        <div class="test-section">
            <h3>â±ï¸ è¶…æ—¶å’Œå–æ¶ˆæµ‹è¯•</h3>
            <div id="timeoutStatus">ç­‰å¾…æµ‹è¯•...</div>
            <div class="log" id="timeoutLog"></div>
        </div>
        
        <div class="test-section">
            <h3>ğŸ”„ é‡å¤è¯·æ±‚æ£€æµ‹</h3>
            <div id="duplicateStatus">ç­‰å¾…æµ‹è¯•...</div>
            <div class="log" id="duplicateLog"></div>
        </div>
        
        <div class="test-section">
            <h3>ğŸŒ æµè§ˆå™¨å…¼å®¹æ€§æµ‹è¯•</h3>
            <div id="compatibilityStatus">ç­‰å¾…æµ‹è¯•...</div>
            <div class="log" id="compatibilityLog"></div>
        </div>
        
        <div class="test-section">
            <h3>ğŸ’¡ è§£å†³æ–¹æ¡ˆå»ºè®®</h3>
            <div id="solutionStatus">ç­‰å¾…è¯Šæ–­...</div>
            <div id="solutionLog"></div>
        </div>
    </div>

    <script>
        const API_BASE_URL = 'https://home-list-api.dylan-chiang.workers.dev';
        let errorCount = 0;
        let testResults = {
            aborted: [],
            timeout: [],
            duplicate: [],
            compatibility: []
        };
        
        function log(section, message, type = 'info') {
            const logElement = document.getElementById(`${section}Log`);
            const timestamp = new Date().toLocaleTimeString();
            const emoji = {
                'info': 'â„¹ï¸',
                'success': 'âœ…',
                'error': 'âŒ',
                'warning': 'âš ï¸'
            }[type] || 'â„¹ï¸';
            
            logElement.innerHTML += `[${timestamp}] ${emoji} ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
            
            if (type === 'error') {
                errorCount++;
                updateErrorSummary();
            }
        }
        
        function updateStatus(section, message, type = 'info') {
            const statusElement = document.getElementById(`${section}Status`);
            statusElement.innerHTML = `<div class="status ${type}">${message}</div>`;
        }
        
        function updateErrorSummary() {
            const summaryElement = document.getElementById('errorSummary');
            if (errorCount > 0) {
                summaryElement.style.display = 'block';
                summaryElement.innerHTML = `<div class="error-count">æ£€æµ‹åˆ° ${errorCount} ä¸ªé”™è¯¯</div>`;
            } else {
                summaryElement.style.display = 'none';
            }
        }
        
        async function testAbortedErrors() {
            log('abort', 'å¼€å§‹ERR_ABORTEDé”™è¯¯æ£€æµ‹...', 'info');
            updateStatus('abort', 'æµ‹è¯•ä¸­...', 'info');
            
            // æµ‹è¯•1: ç«‹å³å–æ¶ˆè¯·æ±‚
            try {
                const controller = new AbortController();
                const fetchPromise = fetch(`${API_BASE_URL}/api/family/members`, {
                    signal: controller.signal,
                    headers: {
                        'Origin': 'http://localhost:5173',
                        'Content-Type': 'application/json'
                    }
                });
                
                // ç«‹å³å–æ¶ˆ
                controller.abort();
                
                await fetchPromise;
                log('abort', 'æ„å¤–ï¼šè¯·æ±‚åº”è¯¥è¢«å–æ¶ˆ', 'warning');
            } catch (error) {
                if (error.name === 'AbortError') {
                    log('abort', 'âœ“ æˆåŠŸæ£€æµ‹åˆ°AbortError', 'success');
                    testResults.aborted.push({ test: 'immediate_abort', status: 'detected' });
                } else {
                    log('abort', `âœ— æ„å¤–é”™è¯¯: ${error.name} - ${error.message}`, 'error');
                    testResults.aborted.push({ test: 'immediate_abort', error: error.message });
                }
            }
            
            // æµ‹è¯•2: å»¶è¿Ÿå–æ¶ˆ
            try {
                const controller = new AbortController();
                const fetchPromise = fetch(`${API_BASE_URL}/api/family/members`, {
                    signal: controller.signal,
                    headers: {
                        'Origin': 'http://localhost:5173',
                        'Content-Type': 'application/json'
                    }
                });
                
                // 50msåå–æ¶ˆ
                setTimeout(() => controller.abort(), 50);
                
                await fetchPromise;
                log('abort', 'è¯·æ±‚åœ¨å–æ¶ˆå‰å®Œæˆ', 'info');
                testResults.aborted.push({ test: 'delayed_abort', status: 'completed' });
            } catch (error) {
                if (error.name === 'AbortError') {
                    log('abort', 'âœ“ å»¶è¿Ÿå–æ¶ˆæˆåŠŸæ£€æµ‹', 'success');
                    testResults.aborted.push({ test: 'delayed_abort', status: 'aborted' });
                } else {
                    log('abort', `âœ— å»¶è¿Ÿå–æ¶ˆé”™è¯¯: ${error.name} - ${error.message}`, 'error');
                    testResults.aborted.push({ test: 'delayed_abort', error: error.message });
                }
            }
            
            // æµ‹è¯•3: é¡µé¢å¸è½½æ¨¡æ‹Ÿ
            try {
                log('abort', 'æ¨¡æ‹Ÿé¡µé¢å¸è½½åœºæ™¯...', 'info');
                const controller = new AbortController();
                
                // æ¨¡æ‹Ÿbeforeunloadäº‹ä»¶
                window.addEventListener('beforeunload', () => {
                    controller.abort();
                });
                
                const response = await fetch(`${API_BASE_URL}/api/family/members`, {
                    signal: controller.signal,
                    headers: {
                        'Origin': 'http://localhost:5173',
                        'Content-Type': 'application/json'
                    }
                });
                
                log('abort', `é¡µé¢å¸è½½æµ‹è¯•å®Œæˆ: HTTP ${response.status}`, 'success');
                testResults.aborted.push({ test: 'page_unload', status: 'completed' });
            } catch (error) {
                log('abort', `é¡µé¢å¸è½½æµ‹è¯•é”™è¯¯: ${error.name} - ${error.message}`, 'error');
                testResults.aborted.push({ test: 'page_unload', error: error.message });
            }
            
            updateStatus('abort', 'ERR_ABORTEDæ£€æµ‹å®Œæˆ', 'success');
        }
        
        async function testTimeoutScenarios() {
            log('timeout', 'å¼€å§‹è¶…æ—¶å’Œå–æ¶ˆæµ‹è¯•...', 'info');
            updateStatus('timeout', 'æµ‹è¯•ä¸­...', 'info');
            
            // æµ‹è¯•1: çŸ­è¶…æ—¶
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    controller.abort();
                    log('timeout', 'è¯·æ±‚å› è¶…æ—¶è¢«å–æ¶ˆ', 'warning');
                }, 100); // 100msè¶…æ—¶
                
                const response = await fetch(`${API_BASE_URL}/api/family/members`, {
                    signal: controller.signal,
                    headers: {
                        'Origin': 'http://localhost:5173',
                        'Content-Type': 'application/json'
                    }
                });
                
                clearTimeout(timeoutId);
                log('timeout', `çŸ­è¶…æ—¶æµ‹è¯•: è¯·æ±‚åœ¨è¶…æ—¶å‰å®Œæˆ HTTP ${response.status}`, 'success');
                testResults.timeout.push({ test: 'short_timeout', status: 'completed' });
            } catch (error) {
                log('timeout', `çŸ­è¶…æ—¶æµ‹è¯•é”™è¯¯: ${error.name} - ${error.message}`, 'error');
                testResults.timeout.push({ test: 'short_timeout', error: error.message });
            }
            
            // æµ‹è¯•2: æ­£å¸¸è¶…æ—¶
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    controller.abort();
                }, 5000); // 5ç§’è¶…æ—¶
                
                const response = await fetch(`${API_BASE_URL}/api/family/members`, {
                    signal: controller.signal,
                    headers: {
                        'Origin': 'http://localhost:5173',
                        'Content-Type': 'application/json'
                    }
                });
                
                clearTimeout(timeoutId);
                log('timeout', `æ­£å¸¸è¶…æ—¶æµ‹è¯•: HTTP ${response.status}`, 'success');
                testResults.timeout.push({ test: 'normal_timeout', status: 'completed' });
            } catch (error) {
                log('timeout', `æ­£å¸¸è¶…æ—¶æµ‹è¯•é”™è¯¯: ${error.name} - ${error.message}`, 'error');
                testResults.timeout.push({ test: 'normal_timeout', error: error.message });
            }
            
            updateStatus('timeout', 'è¶…æ—¶æµ‹è¯•å®Œæˆ', 'success');
        }
        
        async function testDuplicateRequests() {
            log('duplicate', 'å¼€å§‹é‡å¤è¯·æ±‚æ£€æµ‹...', 'info');
            updateStatus('duplicate', 'æµ‹è¯•ä¸­...', 'info');
            
            // æµ‹è¯•å¿«é€Ÿè¿ç»­è¯·æ±‚
            const requests = [];
            const startTime = Date.now();
            
            for (let i = 0; i < 5; i++) {
                requests.push(
                    fetch(`${API_BASE_URL}/api/family/members`, {
                        headers: {
                            'Origin': 'http://localhost:5173',
                            'Content-Type': 'application/json'
                        }
                    }).then(response => ({
                        index: i,
                        status: response.status,
                        timestamp: Date.now() - startTime
                    })).catch(error => ({
                        index: i,
                        error: error.message,
                        timestamp: Date.now() - startTime
                    }))
                );
            }
            
            try {
                const results = await Promise.all(requests);
                results.forEach(result => {
                    if (result.error) {
                        log('duplicate', `è¯·æ±‚ ${result.index}: é”™è¯¯ - ${result.error} (${result.timestamp}ms)`, 'error');
                    } else {
                        log('duplicate', `è¯·æ±‚ ${result.index}: HTTP ${result.status} (${result.timestamp}ms)`, 'success');
                    }
                });
                
                testResults.duplicate = results;
                updateStatus('duplicate', 'é‡å¤è¯·æ±‚æµ‹è¯•å®Œæˆ', 'success');
            } catch (error) {
                log('duplicate', `é‡å¤è¯·æ±‚æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                testResults.duplicate.push({ error: error.message });
            }
        }
        
        async function testBrowserCompatibility() {
            log('compatibility', 'å¼€å§‹æµè§ˆå™¨å…¼å®¹æ€§æµ‹è¯•...', 'info');
            updateStatus('compatibility', 'æµ‹è¯•ä¸­...', 'info');
            
            // æ£€æµ‹æµè§ˆå™¨ä¿¡æ¯
            const browserInfo = {
                userAgent: navigator.userAgent,
                vendor: navigator.vendor,
                platform: navigator.platform,
                cookieEnabled: navigator.cookieEnabled,
                onLine: navigator.onLine
            };
            
            log('compatibility', `æµè§ˆå™¨: ${browserInfo.userAgent}`, 'info');
            log('compatibility', `å¹³å°: ${browserInfo.platform}`, 'info');
            log('compatibility', `Cookieå¯ç”¨: ${browserInfo.cookieEnabled}`, 'info');
            log('compatibility', `åœ¨çº¿çŠ¶æ€: ${browserInfo.onLine}`, 'info');
            
            // æ£€æµ‹Fetch APIæ”¯æŒ
            if (typeof fetch === 'function') {
                log('compatibility', 'âœ“ Fetch API æ”¯æŒ', 'success');
            } else {
                log('compatibility', 'âœ— Fetch API ä¸æ”¯æŒ', 'error');
            }
            
            // æ£€æµ‹AbortControlleræ”¯æŒ
            if (typeof AbortController === 'function') {
                log('compatibility', 'âœ“ AbortController æ”¯æŒ', 'success');
            } else {
                log('compatibility', 'âœ— AbortController ä¸æ”¯æŒ', 'error');
            }
            
            // æ£€æµ‹Promiseæ”¯æŒ
            if (typeof Promise === 'function') {
                log('compatibility', 'âœ“ Promise æ”¯æŒ', 'success');
            } else {
                log('compatibility', 'âœ— Promise ä¸æ”¯æŒ', 'error');
            }
            
            testResults.compatibility = browserInfo;
            updateStatus('compatibility', 'å…¼å®¹æ€§æµ‹è¯•å®Œæˆ', 'success');
        }
        
        function generateSolutions() {
            const solutionLog = document.getElementById('solutionLog');
            solutionLog.innerHTML = '';
            
            const solutions = [];
            
            // åŸºäºæµ‹è¯•ç»“æœç”Ÿæˆè§£å†³æ–¹æ¡ˆ
            const abortErrors = testResults.aborted.filter(r => r.error || r.status === 'aborted').length;
            const timeoutErrors = testResults.timeout.filter(r => r.error).length;
            const duplicateErrors = testResults.duplicate.filter(r => r.error).length;
            
            if (abortErrors > 0) {
                solutions.push({
                    title: 'è§£å†³ ERR_ABORTED é”™è¯¯',
                    content: `
                        1. æ£€æŸ¥æ˜¯å¦æœ‰é‡å¤çš„AbortControllerè°ƒç”¨
                        2. ç¡®ä¿åœ¨ç»„ä»¶å¸è½½æ—¶æ­£ç¡®æ¸…ç†è¯·æ±‚
                        3. é¿å…åœ¨çŸ­æ—¶é—´å†…å‘èµ·å¤§é‡è¯·æ±‚
                        4. ä½¿ç”¨é˜²æŠ–(debounce)æˆ–èŠ‚æµ(throttle)æ§åˆ¶è¯·æ±‚é¢‘ç‡
                    `
                });
            }
            
            if (timeoutErrors > 0) {
                solutions.push({
                    title: 'è§£å†³è¶…æ—¶é—®é¢˜',
                    content: `
                        1. å¢åŠ è¯·æ±‚è¶…æ—¶æ—¶é—´è®¾ç½®
                        2. å®ç°è¯·æ±‚é‡è¯•æœºåˆ¶
                        3. æ£€æŸ¥ç½‘ç»œè¿æ¥çŠ¶å†µ
                        4. ä¼˜åŒ–APIå“åº”é€Ÿåº¦
                    `
                });
            }
            
            if (duplicateErrors > 0) {
                solutions.push({
                    title: 'è§£å†³é‡å¤è¯·æ±‚é—®é¢˜',
                    content: `
                        1. å®ç°è¯·æ±‚å»é‡æœºåˆ¶
                        2. ä½¿ç”¨loadingçŠ¶æ€é˜²æ­¢é‡å¤ç‚¹å‡»
                        3. ç¼“å­˜è¯·æ±‚ç»“æœé¿å…é‡å¤è°ƒç”¨
                        4. ä½¿ç”¨SWRæˆ–React Queryç­‰æ•°æ®è·å–åº“
                    `
                });
            }
            
            // é€šç”¨è§£å†³æ–¹æ¡ˆ
            solutions.push({
                title: 'é€šç”¨ä¼˜åŒ–å»ºè®®',
                content: `
                    1. åœ¨api.tsä¸­æ·»åŠ æ›´robustçš„é”™è¯¯å¤„ç†
                    2. å®ç°æŒ‡æ•°é€€é¿é‡è¯•ç­–ç•¥
                    3. æ·»åŠ è¯·æ±‚æ‹¦æˆªå™¨ç»Ÿä¸€å¤„ç†é”™è¯¯
                    4. ä½¿ç”¨React.useEffectçš„cleanupå‡½æ•°å–æ¶ˆè¯·æ±‚
                    5. è€ƒè™‘ä½¿ç”¨Service Workerç¼“å­˜ç­–ç•¥
                `
            });
            
            solutions.forEach(solution => {
                const solutionDiv = document.createElement('div');
                solutionDiv.className = 'solution';
                solutionDiv.innerHTML = `
                    <h4>${solution.title}</h4>
                    <pre>${solution.content}</pre>
                `;
                solutionLog.appendChild(solutionDiv);
            });
            
            updateStatus('solution', `ç”Ÿæˆäº† ${solutions.length} ä¸ªè§£å†³æ–¹æ¡ˆ`, 'success');
        }
        
        async function simulateErrors() {
            log('abort', 'æ¨¡æ‹ŸERR_ABORTEDåœºæ™¯...', 'warning');
            
            // æ¨¡æ‹Ÿå¿«é€Ÿå–æ¶ˆå¤šä¸ªè¯·æ±‚
            const controllers = [];
            for (let i = 0; i < 3; i++) {
                const controller = new AbortController();
                controllers.push(controller);
                
                fetch(`${API_BASE_URL}/api/family/members`, {
                    signal: controller.signal,
                    headers: {
                        'Origin': 'http://localhost:5173',
                        'Content-Type': 'application/json'
                    }
                }).catch(error => {
                    if (error.name === 'AbortError') {
                        log('abort', `æ¨¡æ‹Ÿè¯·æ±‚ ${i} è¢«å–æ¶ˆ`, 'error');
                    }
                });
                
                // éšæœºæ—¶é—´åå–æ¶ˆ
                setTimeout(() => controller.abort(), Math.random() * 100);
            }
        }
        
        async function runErrorDiagnosis() {
            const startBtn = document.getElementById('startBtn');
            startBtn.disabled = true;
            startBtn.textContent = 'è¯Šæ–­ä¸­...';
            
            errorCount = 0;
            testResults = { aborted: [], timeout: [], duplicate: [], compatibility: [] };
            
            try {
                await testAbortedErrors();
                await testTimeoutScenarios();
                await testDuplicateRequests();
                await testBrowserCompatibility();
                
                generateSolutions();
                
            } catch (error) {
                console.error('è¯Šæ–­è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:', error);
            } finally {
                startBtn.disabled = false;
                startBtn.textContent = 'é‡æ–°è¯Šæ–­';
            }
        }
        
        function clearLogs() {
            ['abort', 'timeout', 'duplicate', 'compatibility'].forEach(section => {
                document.getElementById(`${section}Log`).innerHTML = '';
                updateStatus(section, 'ç­‰å¾…æµ‹è¯•...');
            });
            
            document.getElementById('solutionLog').innerHTML = '';
            updateStatus('solution', 'ç­‰å¾…è¯Šæ–­...');
            
            errorCount = 0;
            updateErrorSummary();
        }
        
        // ç›‘å¬å…¨å±€é”™è¯¯
        window.addEventListener('error', (event) => {
            log('compatibility', `å…¨å±€é”™è¯¯: ${event.error.message}`, 'error');
        });
        
        window.addEventListener('unhandledrejection', (event) => {
            log('compatibility', `æœªå¤„ç†çš„Promiseæ‹’ç»: ${event.reason}`, 'error');
        });
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…¨é¢ç½‘ç»œè¯Šæ–­å·¥å…·</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        h1 {
            color: #2d3748;
            text-align: center;
            margin-bottom: 30px;
        }
        .test-section {
            margin: 20px 0;
            padding: 20px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: #f7fafc;
        }
        .test-section h3 {
            color: #4a5568;
            margin-top: 0;
        }
        .status {
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: bold;
            display: inline-block;
            margin: 5px 0;
        }
        .status.success { background: #c6f6d5; color: #22543d; }
        .status.error { background: #fed7d7; color: #742a2a; }
        .status.warning { background: #fefcbf; color: #744210; }
        .status.info { background: #bee3f8; color: #2a4365; }
        .log {
            background: #1a202c;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            margin: 10px 0;
        }
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        button {
            background: #4299e1;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 0 10px;
            transition: background 0.2s;
        }
        button:hover {
            background: #3182ce;
        }
        button:disabled {
            background: #a0aec0;
            cursor: not-allowed;
        }
        .progress {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-bar {
            height: 100%;
            background: #4299e1;
            transition: width 0.3s;
        }
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .metric {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #4299e1;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #2d3748;
        }
        .metric-label {
            color: #718096;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸŒ å…¨é¢ç½‘ç»œè¯Šæ–­å·¥å…·</h1>
        
        <div class="controls">
            <button onclick="runFullDiagnostic()" id="startBtn">å¼€å§‹å…¨é¢è¯Šæ–­</button>
            <button onclick="clearResults()" id="clearBtn">æ¸…é™¤ç»“æœ</button>
            <button onclick="exportResults()" id="exportBtn">å¯¼å‡ºæŠ¥å‘Š</button>
        </div>
        
        <div class="progress" id="progressContainer" style="display: none;">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        
        <div class="results-grid" id="metricsGrid" style="display: none;"></div>
        
        <div class="test-section">
            <h3>ğŸ” åŸºç¡€è¿é€šæ€§æµ‹è¯•</h3>
            <div id="connectivityStatus">ç­‰å¾…æµ‹è¯•...</div>
            <div class="log" id="connectivityLog"></div>
        </div>
        
        <div class="test-section">
            <h3>ğŸš€ APIç«¯ç‚¹æµ‹è¯•</h3>
            <div id="apiStatus">ç­‰å¾…æµ‹è¯•...</div>
            <div class="log" id="apiLog"></div>
        </div>
        
        <div class="test-section">
            <h3>âš¡ æ€§èƒ½æµ‹è¯•</h3>
            <div id="performanceStatus">ç­‰å¾…æµ‹è¯•...</div>
            <div class="log" id="performanceLog"></div>
        </div>
        
        <div class="test-section">
            <h3>ğŸ”„ é‡è¯•æœºåˆ¶æµ‹è¯•</h3>
            <div id="retryStatus">ç­‰å¾…æµ‹è¯•...</div>
            <div class="log" id="retryLog"></div>
        </div>
        
        <div class="test-section">
            <h3>ğŸ“Š ç½‘ç»œè´¨é‡åˆ†æ</h3>
            <div id="qualityStatus">ç­‰å¾…æµ‹è¯•...</div>
            <div class="log" id="qualityLog"></div>
        </div>
    </div>

    <script>
        const API_BASE_URL = 'https://home-list-api.dylan-chiang.workers.dev';
        const TEST_ENDPOINTS = [
            '/',
            '/api/family/members',
            '/api/family/invites',
            '/api/tasks',
            '/api/auth/me'
        ];
        
        let testResults = {
            connectivity: [],
            api: [],
            performance: [],
            retry: [],
            quality: []
        };
        
        function log(section, message, type = 'info') {
            const logElement = document.getElementById(`${section}Log`);
            const timestamp = new Date().toLocaleTimeString();
            const emoji = {
                'info': 'â„¹ï¸',
                'success': 'âœ…',
                'error': 'âŒ',
                'warning': 'âš ï¸'
            }[type] || 'â„¹ï¸';
            
            logElement.innerHTML += `[${timestamp}] ${emoji} ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
        }
        
        function updateStatus(section, message, type = 'info') {
            const statusElement = document.getElementById(`${section}Status`);
            statusElement.innerHTML = `<div class="status ${type}">${message}</div>`;
        }
        
        function updateProgress(percent) {
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            progressContainer.style.display = 'block';
            progressBar.style.width = `${percent}%`;
        }
        
        function updateMetrics(metrics) {
            const grid = document.getElementById('metricsGrid');
            grid.style.display = 'grid';
            grid.innerHTML = '';
            
            Object.entries(metrics).forEach(([key, value]) => {
                const metric = document.createElement('div');
                metric.className = 'metric';
                metric.innerHTML = `
                    <div class="metric-value">${value.value}</div>
                    <div class="metric-label">${value.label}</div>
                `;
                grid.appendChild(metric);
            });
        }
        
        async function testConnectivity() {
            log('connectivity', 'å¼€å§‹åŸºç¡€è¿é€šæ€§æµ‹è¯•...');
            updateStatus('connectivity', 'æµ‹è¯•ä¸­...', 'info');
            
            const tests = [
                { name: 'DNSè§£æ', test: () => fetch(`${API_BASE_URL}/`, { method: 'HEAD', mode: 'no-cors' }) },
                { name: 'HTTPSè¿æ¥', test: () => fetch(`${API_BASE_URL}/`) },
                { name: 'CORSé¢„æ£€', test: () => fetch(`${API_BASE_URL}/api/family/members`, { method: 'OPTIONS' }) }
            ];
            
            let passed = 0;
            for (const { name, test } of tests) {
                try {
                    const start = performance.now();
                    await test();
                    const duration = performance.now() - start;
                    log('connectivity', `${name}: æˆåŠŸ (${duration.toFixed(2)}ms)`, 'success');
                    testResults.connectivity.push({ name, status: 'success', duration });
                    passed++;
                } catch (error) {
                    log('connectivity', `${name}: å¤±è´¥ - ${error.message}`, 'error');
                    testResults.connectivity.push({ name, status: 'error', error: error.message });
                }
            }
            
            const status = passed === tests.length ? 'success' : passed > 0 ? 'warning' : 'error';
            updateStatus('connectivity', `è¿é€šæ€§æµ‹è¯•å®Œæˆ: ${passed}/${tests.length} é€šè¿‡`, status);
        }
        
        async function testAPIEndpoints() {
            log('api', 'å¼€å§‹APIç«¯ç‚¹æµ‹è¯•...');
            updateStatus('api', 'æµ‹è¯•ä¸­...', 'info');
            
            let passed = 0;
            for (const endpoint of TEST_ENDPOINTS) {
                try {
                    const start = performance.now();
                    const response = await fetch(`${API_BASE_URL}${endpoint}`, {
                        headers: {
                            'Origin': 'http://localhost:5173',
                            'Content-Type': 'application/json'
                        }
                    });
                    const duration = performance.now() - start;
                    
                    const result = {
                        endpoint,
                        status: response.status,
                        duration,
                        headers: Object.fromEntries(response.headers.entries())
                    };
                    
                    if (response.status < 500) {
                        log('api', `${endpoint}: HTTP ${response.status} (${duration.toFixed(2)}ms)`, 'success');
                        testResults.api.push({ ...result, result: 'success' });
                        passed++;
                    } else {
                        log('api', `${endpoint}: HTTP ${response.status} - æœåŠ¡å™¨é”™è¯¯`, 'error');
                        testResults.api.push({ ...result, result: 'error' });
                    }
                } catch (error) {
                    log('api', `${endpoint}: ç½‘ç»œé”™è¯¯ - ${error.message}`, 'error');
                    testResults.api.push({ endpoint, result: 'error', error: error.message });
                }
            }
            
            const status = passed === TEST_ENDPOINTS.length ? 'success' : passed > 0 ? 'warning' : 'error';
            updateStatus('api', `APIæµ‹è¯•å®Œæˆ: ${passed}/${TEST_ENDPOINTS.length} å¯è®¿é—®`, status);
        }
        
        async function testPerformance() {
            log('performance', 'å¼€å§‹æ€§èƒ½æµ‹è¯•...');
            updateStatus('performance', 'æµ‹è¯•ä¸­...', 'info');
            
            const testCases = [
                { name: 'å•æ¬¡è¯·æ±‚', count: 1 },
                { name: 'å¹¶å‘è¯·æ±‚(5)', count: 5 },
                { name: 'è¿ç»­è¯·æ±‚(10)', count: 10, sequential: true }
            ];
            
            for (const { name, count, sequential } of testCases) {
                try {
                    const start = performance.now();
                    
                    if (sequential) {
                        for (let i = 0; i < count; i++) {
                            await fetch(`${API_BASE_URL}/api/family/members`);
                        }
                    } else {
                        const promises = Array(count).fill().map(() => 
                            fetch(`${API_BASE_URL}/api/family/members`)
                        );
                        await Promise.all(promises);
                    }
                    
                    const duration = performance.now() - start;
                    const avgDuration = duration / count;
                    
                    log('performance', `${name}: æ€»æ—¶é—´ ${duration.toFixed(2)}ms, å¹³å‡ ${avgDuration.toFixed(2)}ms`, 'success');
                    testResults.performance.push({ name, totalDuration: duration, avgDuration, count });
                } catch (error) {
                    log('performance', `${name}: å¤±è´¥ - ${error.message}`, 'error');
                    testResults.performance.push({ name, error: error.message });
                }
            }
            
            updateStatus('performance', 'æ€§èƒ½æµ‹è¯•å®Œæˆ', 'success');
        }
        
        async function testRetryMechanism() {
            log('retry', 'å¼€å§‹é‡è¯•æœºåˆ¶æµ‹è¯•...');
            updateStatus('retry', 'æµ‹è¯•ä¸­...', 'info');
            
            // æ¨¡æ‹Ÿç½‘ç»œä¸­æ–­
            const controller = new AbortController();
            setTimeout(() => controller.abort(), 100); // 100msåä¸­æ–­
            
            try {
                await fetch(`${API_BASE_URL}/api/family/members`, {
                    signal: controller.signal
                });
                log('retry', 'æ„å¤–ï¼šè¯·æ±‚åº”è¯¥è¢«ä¸­æ–­', 'warning');
            } catch (error) {
                if (error.name === 'AbortError') {
                    log('retry', 'æˆåŠŸæ¨¡æ‹Ÿç½‘ç»œä¸­æ–­', 'success');
                    testResults.retry.push({ test: 'abort', status: 'success' });
                } else {
                    log('retry', `ä¸­æ–­æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                    testResults.retry.push({ test: 'abort', status: 'error', error: error.message });
                }
            }
            
            // æµ‹è¯•è¶…æ—¶
            const timeoutController = new AbortController();
            setTimeout(() => timeoutController.abort(), 5000);
            
            try {
                const start = performance.now();
                await fetch(`${API_BASE_URL}/api/family/members`, {
                    signal: timeoutController.signal
                });
                const duration = performance.now() - start;
                log('retry', `è¶…æ—¶æµ‹è¯•: è¯·æ±‚å®Œæˆ (${duration.toFixed(2)}ms)`, 'success');
                testResults.retry.push({ test: 'timeout', status: 'success', duration });
            } catch (error) {
                log('retry', `è¶…æ—¶æµ‹è¯•: ${error.message}`, 'warning');
                testResults.retry.push({ test: 'timeout', status: 'timeout', error: error.message });
            }
            
            updateStatus('retry', 'é‡è¯•æœºåˆ¶æµ‹è¯•å®Œæˆ', 'success');
        }
        
        async function analyzeNetworkQuality() {
            log('quality', 'å¼€å§‹ç½‘ç»œè´¨é‡åˆ†æ...');
            updateStatus('quality', 'åˆ†æä¸­...', 'info');
            
            // è®¡ç®—å¹³å‡å“åº”æ—¶é—´
            const apiTimes = testResults.api.filter(r => r.duration).map(r => r.duration);
            const avgResponseTime = apiTimes.length > 0 ? apiTimes.reduce((a, b) => a + b, 0) / apiTimes.length : 0;
            
            // è®¡ç®—æˆåŠŸç‡
            const totalTests = testResults.api.length + testResults.connectivity.length;
            const successfulTests = testResults.api.filter(r => r.result === 'success').length + 
                                  testResults.connectivity.filter(r => r.status === 'success').length;
            const successRate = totalTests > 0 ? (successfulTests / totalTests) * 100 : 0;
            
            // ç½‘ç»œè´¨é‡è¯„çº§
            let quality = 'unknown';
            if (successRate >= 90 && avgResponseTime < 1000) {
                quality = 'excellent';
            } else if (successRate >= 75 && avgResponseTime < 2000) {
                quality = 'good';
            } else if (successRate >= 50 && avgResponseTime < 5000) {
                quality = 'fair';
            } else {
                quality = 'poor';
            }
            
            const qualityLabels = {
                'excellent': 'ä¼˜ç§€',
                'good': 'è‰¯å¥½',
                'fair': 'ä¸€èˆ¬',
                'poor': 'è¾ƒå·®',
                'unknown': 'æœªçŸ¥'
            };
            
            log('quality', `å¹³å‡å“åº”æ—¶é—´: ${avgResponseTime.toFixed(2)}ms`, 'info');
            log('quality', `æˆåŠŸç‡: ${successRate.toFixed(1)}%`, 'info');
            log('quality', `ç½‘ç»œè´¨é‡: ${qualityLabels[quality]}`, quality === 'excellent' || quality === 'good' ? 'success' : 'warning');
            
            testResults.quality = {
                avgResponseTime,
                successRate,
                quality,
                qualityLabel: qualityLabels[quality]
            };
            
            updateStatus('quality', `ç½‘ç»œè´¨é‡åˆ†æå®Œæˆ: ${qualityLabels[quality]}`, quality === 'excellent' || quality === 'good' ? 'success' : 'warning');
            
            // æ›´æ–°æŒ‡æ ‡æ˜¾ç¤º
            updateMetrics({
                responseTime: { value: `${avgResponseTime.toFixed(0)}ms`, label: 'å¹³å‡å“åº”æ—¶é—´' },
                successRate: { value: `${successRate.toFixed(1)}%`, label: 'æˆåŠŸç‡' },
                quality: { value: qualityLabels[quality], label: 'ç½‘ç»œè´¨é‡' },
                totalTests: { value: totalTests, label: 'æ€»æµ‹è¯•æ•°' }
            });
        }
        
        async function runFullDiagnostic() {
            const startBtn = document.getElementById('startBtn');
            startBtn.disabled = true;
            startBtn.textContent = 'è¯Šæ–­ä¸­...';
            
            testResults = { connectivity: [], api: [], performance: [], retry: [], quality: [] };
            
            try {
                updateProgress(10);
                await testConnectivity();
                
                updateProgress(30);
                await testAPIEndpoints();
                
                updateProgress(50);
                await testPerformance();
                
                updateProgress(70);
                await testRetryMechanism();
                
                updateProgress(90);
                await analyzeNetworkQuality();
                
                updateProgress(100);
                
                // ç”Ÿæˆè¯Šæ–­å»ºè®®
                generateRecommendations();
                
            } catch (error) {
                console.error('è¯Šæ–­è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:', error);
            } finally {
                startBtn.disabled = false;
                startBtn.textContent = 'é‡æ–°è¯Šæ–­';
            }
        }
        
        function generateRecommendations() {
            const quality = testResults.quality;
            let recommendations = [];
            
            if (quality.successRate < 80) {
                recommendations.push('â€¢ ç½‘ç»œè¿æ¥ä¸ç¨³å®šï¼Œå»ºè®®æ£€æŸ¥ç½‘ç»œè®¾ç½®');
            }
            
            if (quality.avgResponseTime > 2000) {
                recommendations.push('â€¢ å“åº”æ—¶é—´è¾ƒæ…¢ï¼Œå¯èƒ½æ˜¯ç½‘ç»œå»¶è¿Ÿæˆ–æœåŠ¡å™¨è´Ÿè½½é—®é¢˜');
            }
            
            const failedConnectivity = testResults.connectivity.filter(r => r.status === 'error');
            if (failedConnectivity.length > 0) {
                recommendations.push('â€¢ åŸºç¡€è¿é€šæ€§æµ‹è¯•å¤±è´¥ï¼Œè¯·æ£€æŸ¥é˜²ç«å¢™å’ŒDNSè®¾ç½®');
            }
            
            const failedAPI = testResults.api.filter(r => r.result === 'error');
            if (failedAPI.length > 0) {
                recommendations.push('â€¢ éƒ¨åˆ†APIç«¯ç‚¹æ— æ³•è®¿é—®ï¼Œå¯èƒ½æ˜¯æœåŠ¡å™¨é—®é¢˜');
            }
            
            if (recommendations.length > 0) {
                log('quality', 'è¯Šæ–­å»ºè®®:', 'info');
                recommendations.forEach(rec => log('quality', rec, 'warning'));
            } else {
                log('quality', 'ç½‘ç»œçŠ¶å†µè‰¯å¥½ï¼Œæ— éœ€ç‰¹æ®Šå¤„ç†', 'success');
            }
        }
        
        function clearResults() {
            ['connectivity', 'api', 'performance', 'retry', 'quality'].forEach(section => {
                document.getElementById(`${section}Log`).innerHTML = '';
                updateStatus(section, 'ç­‰å¾…æµ‹è¯•...');
            });
            
            document.getElementById('progressContainer').style.display = 'none';
            document.getElementById('metricsGrid').style.display = 'none';
            testResults = { connectivity: [], api: [], performance: [], retry: [], quality: [] };
        }
        
        function exportResults() {
            const report = {
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent,
                results: testResults,
                summary: {
                    totalTests: Object.values(testResults).flat().length,
                    networkQuality: testResults.quality.qualityLabel || 'æœªçŸ¥'
                }
            };
            
            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `network-diagnostic-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // é¡µé¢åŠ è½½å®Œæˆåè‡ªåŠ¨è¿è¡Œä¸€æ¬¡åŸºç¡€æµ‹è¯•
        window.addEventListener('load', () => {
            setTimeout(() => {
                log('connectivity', 'é¡µé¢åŠ è½½å®Œæˆï¼Œå¯ä»¥å¼€å§‹è¯Šæ–­', 'info');
            }, 1000);
        });
    </script>
</body>
</html>
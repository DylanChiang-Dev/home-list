<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>实时错误捕获工具</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e5e5e5;
        }
        .status {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .status-card {
            flex: 1;
            min-width: 200px;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
        }
        .status-card.error { background: #fee; border-left: 4px solid #f56565; }
        .status-card.warning { background: #fff3cd; border-left: 4px solid #ffc107; }
        .status-card.success { background: #d4edda; border-left: 4px solid #28a745; }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .btn-primary { background: #007bff; color: white; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-warning { background: #ffc107; color: black; }
        .log-container {
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #f8f9fa;
        }
        .log-entry {
            padding: 10px;
            border-bottom: 1px solid #eee;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
        }
        .log-entry.error { background: #fee; border-left: 3px solid #f56565; }
        .log-entry.warning { background: #fff3cd; border-left: 3px solid #ffc107; }
        .log-entry.info { background: #d1ecf1; border-left: 3px solid #17a2b8; }
        .timestamp { color: #666; font-size: 11px; }
        .error-type { font-weight: bold; color: #d63384; }
        .url { color: #0066cc; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔍 实时错误捕获工具</h1>
            <p>专门用于捕获和分析 ERR_ABORTED 和 Failed to fetch 错误</p>
        </div>

        <div class="status">
            <div class="status-card error">
                <h3>ERR_ABORTED</h3>
                <div id="aborted-count">0</div>
            </div>
            <div class="status-card warning">
                <h3>Failed to fetch</h3>
                <div id="fetch-failed-count">0</div>
            </div>
            <div class="status-card success">
                <h3>成功请求</h3>
                <div id="success-count">0</div>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-primary" onclick="testFamilyAPI()">测试家庭API</button>
            <button class="btn btn-warning" onclick="testWithCancel()">测试取消请求</button>
            <button class="btn btn-success" onclick="testConcurrent()">测试并发请求</button>
            <button class="btn btn-danger" onclick="clearLogs()">清除日志</button>
            <button class="btn btn-primary" onclick="exportLogs()">导出日志</button>
        </div>

        <div class="log-container" id="log-container">
            <div class="log-entry info">
                <span class="timestamp">[启动]</span> 错误监控已启动，等待捕获错误...
            </div>
        </div>
    </div>

    <script>
        let errorCounts = {
            aborted: 0,
            fetchFailed: 0,
            success: 0
        };
        let logs = [];

        // 更新计数器显示
        function updateCounters() {
            document.getElementById('aborted-count').textContent = errorCounts.aborted;
            document.getElementById('fetch-failed-count').textContent = errorCounts.fetchFailed;
            document.getElementById('success-count').textContent = errorCounts.success;
        }

        // 添加日志条目
        function addLog(type, message, details = {}) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = {
                timestamp,
                type,
                message,
                details,
                id: Date.now() + Math.random()
            };
            
            logs.push(logEntry);
            
            const logContainer = document.getElementById('log-container');
            const logDiv = document.createElement('div');
            logDiv.className = `log-entry ${type}`;
            
            let detailsStr = '';
            if (details.url) detailsStr += `<br><span class="url">URL: ${details.url}</span>`;
            if (details.status) detailsStr += `<br>状态: ${details.status}`;
            if (details.error) detailsStr += `<br>错误: ${details.error}`;
            
            logDiv.innerHTML = `
                <span class="timestamp">[${timestamp}]</span>
                <span class="error-type">[${type.toUpperCase()}]</span>
                ${message}
                ${detailsStr}
            `;
            
            logContainer.appendChild(logDiv);
            logContainer.scrollTop = logContainer.scrollHeight;
            
            // 限制日志数量
            if (logs.length > 100) {
                logs.shift();
                logContainer.removeChild(logContainer.children[1]); // 保留第一个启动消息
            }
        }

        // 拦截 fetch 请求
        const originalFetch = window.fetch;
        window.fetch = async function(...args) {
            const url = args[0];
            const options = args[1] || {};
            
            addLog('info', `发起请求: ${url}`);
            
            try {
                const response = await originalFetch.apply(this, args);
                
                if (response.ok) {
                    errorCounts.success++;
                    addLog('info', `请求成功`, { url, status: response.status });
                } else {
                    addLog('warning', `HTTP错误`, { url, status: response.status });
                }
                
                updateCounters();
                return response;
            } catch (error) {
                console.error('Fetch error caught:', error);
                
                if (error.name === 'AbortError' || error.message.includes('aborted')) {
                    errorCounts.aborted++;
                    addLog('error', `ERR_ABORTED: 请求被取消`, { url, error: error.message });
                } else if (error.message.includes('Failed to fetch') || error.message.includes('fetch')) {
                    errorCounts.fetchFailed++;
                    addLog('error', `Failed to fetch: 网络请求失败`, { url, error: error.message });
                } else {
                    addLog('error', `其他网络错误: ${error.message}`, { url, error: error.message });
                }
                
                updateCounters();
                throw error;
            }
        };

        // 捕获全局错误
        window.addEventListener('error', (event) => {
            console.error('Global error caught:', event.error);
            addLog('error', `全局错误: ${event.error?.message || event.message}`, {
                error: event.error?.stack || event.error?.message
            });
        });

        // 捕获未处理的 Promise 拒绝
        window.addEventListener('unhandledrejection', (event) => {
            console.error('Unhandled promise rejection:', event.reason);
            
            const reason = event.reason;
            if (reason?.name === 'AbortError' || reason?.message?.includes('aborted')) {
                errorCounts.aborted++;
                addLog('error', `未处理的 ERR_ABORTED`, { error: reason.message });
            } else if (reason?.message?.includes('Failed to fetch')) {
                errorCounts.fetchFailed++;
                addLog('error', `未处理的 Failed to fetch`, { error: reason.message });
            } else {
                addLog('error', `未处理的 Promise 拒绝: ${reason?.message || reason}`, {
                    error: reason?.stack || reason?.message || reason
                });
            }
            
            updateCounters();
        });

        // 测试函数
        async function testFamilyAPI() {
            addLog('info', '开始测试家庭管理API...');
            
            const endpoints = [
                'http://localhost:5173/api/family/members',
                'http://localhost:5173/api/family/invites',
                'https://home-list-api.zhangkaishen.workers.dev/api/family/members',
                'https://home-list-api.zhangkaishen.workers.dev/api/family/invites'
            ];
            
            for (const endpoint of endpoints) {
                try {
                    await fetch(endpoint, {
                        method: 'GET',
                        headers: {
                            'Authorization': 'Bearer test-token',
                            'Content-Type': 'application/json'
                        }
                    });
                } catch (error) {
                    // 错误已经被拦截器处理
                }
                
                // 等待一下再测试下一个
                await new Promise(resolve => setTimeout(resolve, 500));
            }
        }

        async function testWithCancel() {
            addLog('info', '测试取消请求...');
            
            const controller = new AbortController();
            
            // 1秒后取消请求
            setTimeout(() => {
                controller.abort();
                addLog('warning', '手动取消了请求');
            }, 1000);
            
            try {
                await fetch('https://home-list-api.zhangkaishen.workers.dev/api/family/members', {
                    signal: controller.signal,
                    headers: {
                        'Authorization': 'Bearer test-token'
                    }
                });
            } catch (error) {
                // 错误已经被拦截器处理
            }
        }

        async function testConcurrent() {
            addLog('info', '测试并发请求...');
            
            const promises = [];
            for (let i = 0; i < 5; i++) {
                promises.push(
                    fetch('https://home-list-api.zhangkaishen.workers.dev/api/family/members', {
                        headers: {
                            'Authorization': 'Bearer test-token'
                        }
                    }).catch(() => {}) // 忽略错误，让拦截器处理
                );
            }
            
            await Promise.allSettled(promises);
            addLog('info', '并发测试完成');
        }

        function clearLogs() {
            logs = [];
            errorCounts = { aborted: 0, fetchFailed: 0, success: 0 };
            updateCounters();
            
            const logContainer = document.getElementById('log-container');
            logContainer.innerHTML = `
                <div class="log-entry info">
                    <span class="timestamp">[清除]</span> 日志已清除，重新开始监控...
                </div>
            `;
        }

        function exportLogs() {
            const data = {
                timestamp: new Date().toISOString(),
                counts: errorCounts,
                logs: logs
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `error-logs-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            URL.revokeObjectURL(url);
            addLog('info', '日志已导出');
        }

        // 页面加载完成后自动开始监控
        window.addEventListener('load', () => {
            addLog('info', '页面加载完成，开始监控网络请求...');
            
            // 自动测试一次
            setTimeout(() => {
                addLog('info', '自动开始测试...');
                testFamilyAPI();
            }, 2000);
        });

        // 定期更新显示
        setInterval(updateCounters, 1000);
    </script>
</body>
</html>